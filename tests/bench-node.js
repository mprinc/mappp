// Generated by CoffeeScript 1.10.0
(function() {
  var _, bench, counter, i, iS, j, map, obj, speedr;

  speedr = require('../speedr');

  _ = require('underscore');

  bench = function(name, f) {
    var after, before;
    before = new Date();
    f();
    after = new Date();
    return console.log(name + ": " + (after.getTime() - before.getTime()) + " ms");
  };

  obj = {};

  map = new speedr.Map();

  for (i = j = 0; j <= 1000000; i = ++j) {
    iS = i.toString();
    obj[iS] = iS;
    map.set([iS, iS]);
  }

  counter = 0;

  bench('Normal object for loop (keys only)', function() {
    var k, results;
    results = [];
    for (k in obj) {
      results.push(counter++);
    }
    return results;
  });

  counter = 0;

  bench('Normal object for loop (keys and values)', function() {
    var k, results, v;
    results = [];
    for (k in obj) {
      v = obj[k];
      results.push(counter++);
    }
    return results;
  });

  counter = 0;

  bench('speedr.js map eachKey function', function() {
    return map.eachKey(function(k) {
      return counter++;
    });
  });

  counter = 0;

  bench('speedr.js map eachVal function', function() {
    return map.eachVal(function(v) {
      return counter++;
    });
  });

  counter = 0;

  bench('speedr.js map each function', function() {
    return map.each(function(k, v) {
      return counter++;
    });
  });

  counter = 0;

  bench('speedr.js map iterKey function', function() {
    var k, l, ref, results;
    results = [];
    for (i = l = 0, ref = map.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      k = map.iterKey(i);
      results.push(counter++);
    }
    return results;
  });

  counter = 0;

  bench('speedr.js map iterVal function', function() {
    var l, ref, results, v;
    results = [];
    for (i = l = 0, ref = map.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      v = map.iterVal(i);
      results.push(counter++);
    }
    return results;
  });

  counter = 0;

  bench('speedr.js map iter function', function() {
    var k, l, ref, ref1, results, v;
    results = [];
    for (i = l = 0, ref = map.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      ref1 = map.iter(i), k = ref1[0], v = ref1[1];
      results.push(counter++);
    }
    return results;
  });

}).call(this);
